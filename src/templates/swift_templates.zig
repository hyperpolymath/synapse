// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2024 Synapse Contributors
//
// SYNAPSE - Swift Template System
//
// THE APPLE STORE COMPLIANCE LAYER
// ================================
// When Apple releases iOS 19 and deprecates @Observable for something new,
// you update THESE templates. Then run `just gen-ui`. Done.
//
// No more manually updating 50 ViewModel files.

const std = @import("std");
const types = @import("types");
const parser = @import("parser");

const SynapseConfig = types.SynapseConfig;

/// Write the file header with imports and generation notice
pub fn writeHeader(writer: anytype, config: SynapseConfig) !void {
    try writer.print(
        \\// ============================================
        \\// AUTO-GENERATED BY SYNAPSE - DO NOT EDIT
        \\// ============================================
        \\// iOS {d}+ Compliant | Generated: {s}
        \\// Re-run `just gen-ui` to regenerate
        \\//
        \\// This file bridges Rust structs to SwiftUI ViewModels.
        \\// The source of truth lives in Rust. This is just the interface.
        \\// ============================================
        \\
        \\import SwiftUI
        \\import Foundation
        \\import Observation
        \\
        \\// Import your UniFFI-generated module here:
        \\// import DriftCore
        \\
        \\
    , .{ config.ios_version, "TIMESTAMP" });
}

/// Generate a ViewModel class for a Rust struct
pub fn generateViewModel(writer: anytype, rust_struct: parser.RustStruct, config: SynapseConfig) !void {
    const name = rust_struct.name;

    // Write doc comment if present
    if (rust_struct.doc_comment) |doc| {
        try writer.print("/// {s}\n", .{doc});
    }

    // iOS 17+ uses @Observable macro, older uses ObservableObject protocol
    if (config.use_observable and config.ios_version >= 17) {
        try generateObservableViewModel(writer, rust_struct);
    } else {
        try generateLegacyViewModel(writer, rust_struct);
    }

    // Generate convenience initializer
    try writer.print(
        \\
        \\extension {s}ViewModel {{
        \\    /// Create from UniFFI-bridged Rust struct
        \\    static func from(rust: {s}) -> {s}ViewModel {{
        \\        return {s}ViewModel(
    , .{ name, name, name, name });

    // Generate initializer parameters
    for (rust_struct.fields.items, 0..) |field, idx| {
        if (idx > 0) try writer.writeAll(",");
        try writer.print("\n            {s}: rust.{s}", .{ field.name, field.name });
    }

    try writer.print(
        \\
        \\        )
        \\    }}
        \\}}
        \\
        \\
    , .{});
}

/// iOS 17+ @Observable macro version
fn generateObservableViewModel(writer: anytype, rust_struct: parser.RustStruct) !void {
    const name = rust_struct.name;

    try writer.print(
        \\// MARK: - {s}ViewModel (iOS 17+ @Observable)
        \\@Observable
        \\@MainActor
        \\final class {s}ViewModel {{
        \\
    , .{ name, name });

    // Generate properties
    for (rust_struct.fields.items) |field| {
        try writeSwiftProperty(writer, field, false);
    }

    // Generate initializer
    try writer.print(
        \\
        \\    init(
    , .{});

    for (rust_struct.fields.items, 0..) |field, idx| {
        if (idx > 0) try writer.writeAll(",");
        const swift_type = mapRustTypeToSwift(field);
        const default_val = getDefaultValue(field);
        try writer.print("\n        {s}: {s} = {s}", .{ field.name, swift_type, default_val });
    }

    try writer.print(
        \\
        \\    ) {{
        \\
    , .{});

    for (rust_struct.fields.items) |field| {
        try writer.print("        self.{s} = {s}\n", .{ field.name, field.name });
    }

    try writer.print(
        \\    }}
        \\}}
        \\
    , .{});
}

/// Legacy ObservableObject version for iOS 14-16
fn generateLegacyViewModel(writer: anytype, rust_struct: parser.RustStruct) !void {
    const name = rust_struct.name;

    try writer.print(
        \\// MARK: - {s}ViewModel (Legacy ObservableObject)
        \\@MainActor
        \\final class {s}ViewModel: ObservableObject {{
        \\
    , .{ name, name });

    // Generate @Published properties
    for (rust_struct.fields.items) |field| {
        try writeSwiftProperty(writer, field, true);
    }

    // Generate initializer
    try writer.print(
        \\
        \\    init(
    , .{});

    for (rust_struct.fields.items, 0..) |field, idx| {
        if (idx > 0) try writer.writeAll(",");
        const swift_type = mapRustTypeToSwift(field);
        const default_val = getDefaultValue(field);
        try writer.print("\n        {s}: {s} = {s}", .{ field.name, swift_type, default_val });
    }

    try writer.print(
        \\
        \\    ) {{
        \\
    , .{});

    for (rust_struct.fields.items) |field| {
        try writer.print("        self.{s} = {s}\n", .{ field.name, field.name });
    }

    try writer.print(
        \\    }}
        \\}}
        \\
    , .{});
}

fn writeSwiftProperty(writer: anytype, field: parser.RustField, use_published: bool) !void {
    const swift_type = mapRustTypeToSwift(field);

    if (field.doc_comment) |doc| {
        try writer.print("    /// {s}\n", .{doc});
    }

    if (use_published) {
        try writer.print("    @Published var {s}: {s}\n", .{ field.name, swift_type });
    } else {
        try writer.print("    var {s}: {s}\n", .{ field.name, swift_type });
    }
}

fn mapRustTypeToSwift(field: parser.RustField) []const u8 {
    return switch (field.rust_type) {
        .i8, .i16, .i32 => "Int",
        .i64 => "Int64",
        .u8, .u16, .u32 => "UInt",
        .u64 => "UInt64",
        .f32 => "Float",
        .f64 => "Double",
        .bool => "Bool",
        .String => "String",
        .Vec => "[Any]", // TODO: Extract generic param
        .Option => "Any?", // TODO: Extract generic param
        .custom => field.type_name,
    };
}

fn getDefaultValue(field: parser.RustField) []const u8 {
    return switch (field.rust_type) {
        .i8, .i16, .i32, .i64 => "0",
        .u8, .u16, .u32, .u64 => "0",
        .f32, .f64 => "0.0",
        .bool => "false",
        .String => "\"\"",
        .Vec => "[]",
        .Option => "nil",
        .custom => "nil",
    };
}

/// Generate SwiftUI Preview providers
pub fn generatePreviews(writer: anytype, structs: []const parser.RustStruct, config: SynapseConfig) !void {
    _ = config;

    try writer.writeAll(
        \\// MARK: - SwiftUI Previews
        \\
        \\#if DEBUG
        \\
    );

    for (structs) |s| {
        try writer.print(
            \\struct {s}ViewModel_Previews: PreviewProvider {{
            \\    static var previews: some View {{
            \\        Text("{s} Preview")
            \\            .environmentObject({s}ViewModel())
            \\    }}
            \\}}
            \\
            \\
        , .{ s.name, s.name, s.name });
    }

    try writer.writeAll("#endif\n");
}

test "generate header" {
    var buffer = std.ArrayList(u8).init(std.testing.allocator);
    defer buffer.deinit();

    const config = SynapseConfig{
        .input_path = "test.rs",
        .output_path = "test.swift",
        .ios_version = 17,
    };

    try writeHeader(buffer.writer(), config);
    try std.testing.expect(buffer.items.len > 0);
}
